# データベースと認証基盤のセットアップサマリー

このドキュメントは、認証システムと業務ロジックを完全に分離するための初期設計と実装作業、およびDBスキーマの確立に関する変更点の総整理です。

このPRには、今後のアプリケーション開発の前提となる**認証 ID の分離**と**データベースの基盤**が含まれています。

---

## ✅ 完了した作業の総整理

### 🎯 目的：認証システムの分離とDBスキーマの確立

| フェーズ | 目的 |
| :--- | :--- |
| **I. 認証システム (Better Auth) の準備** | 認証と業務ロジックを分離し、将来的な変更に強い疎結合な認証基盤を構築する。 |
| **II. DBスキーマ設計とマイグレーション** | プロジェクト全体の命名規則に従い、ローカル環境で動くデータベーススキーマを確立する。 |
| **III. 開発環境の整備** | チームメンバーが DB を確認し、次の開発ステップに進めるためのローカル環境設定を完了させる。 |

---

## 💻 成果物と具体的な変更内容

| 分類 | 変更ファイル / コマンド | 詳細な作業内容 |
| :--- | :--- | :--- |
| **1. 認証ID分離設計** | `src/auth.ts`, `auth-cli.ts` | Better Authが使用する全テーブル名に **`auth_` プレフィックス**を適用し、業務テーブルとの衝突を回避。 |
| **2. 命名規則の統一** | `src/auth.ts`, `auth-cli.ts`, `src/db/schema/auth-schema.ts` | DBテーブル名をすべて**複数形**に統一（例: `auth_user` → `auth_users`）。 |
| **3. 変数名の統一** | `src/db/schema/auth-schema.ts` | Drizzleのスキーマ定義で、`export const` 変数名を**キャメルケース**に統一（例: `auth_users`）。 |
| **4. 業務スキーマの定義** | `src/db/schema/user.ts` (新規作成) | **コア業務テーブル** (`users`) と、認証IDと業務IDを紐づける**中間テーブル** (`auth_mappings`) を定義。 `auth_mappings` には 1対1 を保証する **`primaryKey`** と **`unique`** 制約を設定。 |
| **5. マイグレーションファイル生成** | `pnpm generate` | DBスキーマのすべての変更（`auth_users`, `users`, `auth_mappings` など）を反映した**マイグレーション SQL ファイル**を生成し、`drizzle/` ディレクトリに追加。 |
| **6. ローカルDB適用** | `pnpm local:migration` | 生成されたマイグレーションファイルをローカルの D1 データベースに適用し、すべてのテーブルを正常に作成。 |
| **7. 開発環境設定** | `drizzle.config.ts` | Drizzle Studio（ローカルDB確認ツール）接続のため、`dbCredentials` を追加し、ローカル D1 DBファイルパスを設定。 |
| **8. 開発依存関係** | `package.json`, `pnpm install` | Drizzle Studio 動作のために、SQLiteドライバーである **`better-sqlite3`** を開発依存関係に追加しインストール。 |

---

### 🔑 次のステップ（実装予定）

この基盤を元に、次に以下の重要なロジックを実装する必要があります。

1.  Hono ルートの統合とコンテキストの整備 (`src/index.ts` の修正)。
2.  ID マッピング処理の実装（新規ユーザー登録時の `users` テーブルへのデータ挿入）。
3.  API 保護ミドルウェアの実装（セッションチェックと業務 ID への変換）。


ここまでの作業を通して、データベース設計、認証システム連携、およびチーム開発の効率化に関する多くの重要な概念を実践的に学びました。

学んだことを「技術的知識」「設計原則」「開発プラクティス」の3つのカテゴリに分けて整理します。

---

## 💻 1. 技術的知識（Drizzle, Better Auth, Hono, pnpm）

### データベースとORM (Drizzle ORM)
* **Drizzle ORM の役割:** TypeScript のスキーマ定義を元に、SQL マイグレーションファイルを生成する仕組みを理解しました。
* **カスタム設定:** ローカル開発環境の D1 DB ファイルに接続するため、`drizzle.config.ts` に **`dbCredentials`** を設定する方法（ローカルツール専用の設定）を学びました。
* **ネイティブ依存関係:** Drizzle Kit Studio の実行には、`better-sqlite3` のような**ネイティブドライバー**が必要であり、pnpm 環境でそれがビルドされないと **Bindingsエラー**が発生することを経験し、その解決策（ビルドの許可や再インストール）を学びました。

### 認証システム (Better Auth)
* **アイデンティティモデル:** Better Auth が **1つの正規ユーザー (`auth_users`)** を中心に、複数の認証手段 (`auth_accounts`) を紐づける **1対多** のモデルを採用していることを理解しました。
* **フックの利用:** 認証が成功した直後にカスタムロジックを挿入するためには、**`callbacks` や `events`** のフック機能を利用する必要があることを学びました。

### 実行環境 (Wrangler & pnpm)
* **マイグレーションパス:** Wrangler がマイグレーションファイルを正しく見つけるために、`wrangler.toml` に **`migrations_dir`** を明示的に設定する必要があることを学びました。
* **D1 ローカル適用:** `wrangler d1 migrations apply --local` コマンドが、ローカル開発サーバーが使用する D1 DB に変更を適用する唯一の方法であることを確認しました。
* **ファイルロックと権限:** Windows/pnpm 環境でネイティブモジュールやロックファイルが原因で発生する **`EPERM` エラー**（アクセス権限エラー）に遭遇し、その解決策としてプロセスの終了やクリーンな再インストールが有効であることを学びました。

---

## 📐 2. 設計原則（セキュリティと一貫性）

### 認証と業務ロジックの分離 (疎結合)
* **ID 分離の重要性:** 認証システム (`auth_users`) と業務システム (`users`) を完全に分離し、間に **`auth_mappings`** テーブルを挟むことで、将来的に認証システムを入れ替えても、業務ロジックに影響を与えない**疎結合**な設計を実現しました。
* **セキュリティ:** 外部に露出する API で、セキュリティ上重要でない **業務 ID** (`users.id`) を使用し、**外部認証 ID** (`auth_users.id`) の露出を防ぐ設計の基本を学びました。

### 命名規則の統一 (一貫性)
* **DB テーブル名:** プロジェクト全体で一貫性を保つため、すべてのテーブル名を **複数形（Snake Case）** に統一しました (`auth_users`, `auth_mappings`, `users`)。
* **TypeScript 変数名:** TypeScript のコーディング規約に合わせ、スキーマ定義の `export const` 変数名を **キャメルケース** に統一しました (`authUser`, `authMappings`)。
* **1対1 マッピング:** 1対1 のリレーションシップを表現する中間テーブルには、機能が明確に伝わる **`auth_mappings`** が、多対多を連想させる `user_auth_rels` よりも適切であることを学びました。

---

## 👥 3. 開発プラクティス（チーム開発と運用）

### 開発体験 (DX) の重要性
* **DB 確認手段の提供:** チームメンバーが DB の中身を容易に確認できるように、Drizzle Studio の起動環境を整備し、そのための設定（`drizzle.config.ts`）を完了させました。

### コミットの粒度と運用
* **段階的なマイグレーション:** Auth スキーマと User スキーマを分けて `generate` コマンドを実行し、それぞれを独立した `chore` コミットとして記録することで、**マイグレーション履歴の論理的な分離**を図る運用プラクティスを学びました。
* **PR の明確化:** 最初の大きな PR のスコープを「DBと認証基盤の確立」に明確に定め、次の PR で「Honoルーティングと認証ロジック」に移ることで、レビューしやすい、論理的な作業分割の重要性を学びました。
* **ドキュメント化:** 重要な設計変更と設定作業をまとめたドキュメント（`SETUP_DATABASE_AND_AUTH.md`）を作成し、チームメンバーへの情報共有と、将来の参照を容易にするプラクティスを実践しました。


ここまでのプロジェクトの進捗、お疲れ様でした！非常に重要な基盤構築のフェーズが完了しました。

これまでの作業を振り返り、特に重要な成果と、次のフェーズで活かすべき教訓をまとめます。

---

## 🎯 振り返り：達成された主要な成果

### 1. データベース基盤の確立 (DB & ORM)
* **疎結合な設計の実現:** 認証ID (`auth_users`) と業務ID (`users`) を完全に分離し、`auth_mappings` テーブルを介して紐づけるという、**セキュリティと保守性の高い**データベース設計を確立しました。
* **命名規則の統一:** プロジェクト全体で一貫した命名規則（テーブル名：**複数形**、変数名：**キャメルケース**）を採用し、DBとTypeScriptコード間の可読性を高めました。
* **Drizzle マイグレーションの完了:** ローカル開発環境の D1 データベースにすべてのコアテーブルを適用し、**データ基盤の準備**を整えました。

### 2. 認証システム連携の準備 (Better Auth)
* **衝突回避:** Better Authが使用するすべてのテーブルに `auth_` プレフィックスを適用することで、将来的なテーブル名衝突のリスクを排除しました。
* **環境整備:** Drizzle Kit Studio の接続環境 (`drizzle.config.ts`) や、必要な依存関係 (`better-sqlite3`) の整備を完了させ、次の実装ステップへ進むための準備が整いました。

---

## 💡 今後の開発に活かすべき教訓

### 1. 設計と実装のトレードオフ
* **単数形/複数形の統一:** DBテーブルの命名規則は、一度決めたら変えるのが大変です。初期段階で徹底的に議論し、プロジェクト全体で一貫させることの重要性を再認識しました。
* **1対1 マッピングの明示:** `auth_mappings` のテーブル名決定において、リレーションシップが **1対1** であることを考慮し、多対多を連想させる名前を避ける判断は、将来の誤解を防ぐ良いプラクティスとなりました。

### 2. ツールチェーンの深い理解
* **ローカル環境の複雑性:** Drizzle Kit が Cloudflare Workers のローカル D1 DB に接続する際、**`wrangler.toml`**、**`drizzle.config.ts`**、**ネイティブ依存関係** (`better-sqlite3`) のすべてが正しく連携する必要があることを学びました。特に、ローカル環境のファイルパスやネイティブモジュールのビルドエラーは、**ツールチェーンに特有の課題**であり、その解決方法を経験として習得しました。

### 3. コミットとPRの分割
* **論理的な分割:** 今回、スキーマの修正とマイグレーションファイルの生成を論理的に分割してコミットすることで、**作業履歴の明確化**が図られました。次のフェーズでも、「ルーティング統合」「マッピングロジック実装」「ミドルウェア実装」のように、**機能単位でPRを分割**するプラクティスを継続することが、効率的なチーム開発に繋がります。

---

## ➡️ 次のフェーズへ

今後は、この強固な基盤の上で、Hono を使った認証ロジックと API の実装に進みます。

**次に取り組むべきは、以下のフェーズ 1 の残り 3 ステップです。**

1.  Hono ルートの統合とコンテキストの整備
2.  ID マッピング処理の実装
3.  API 保護ミドルウェアの実装


## 次のプロンプト準備
現在のコードベース全体を踏まえ、次のフェーズである「**🚀 フェーズ 1: アプリケーションの動作環境の完成**」の残り 3 ステップを実装するための、具体的な指示プロンプトを作成します。

このプロンプトでは、現在のコードの問題点（DB/Authインスタンスの重複生成）を解決しつつ、ID分離設計の核となるロジックの実装を求めます。

---

## 💻 次のステップへの指示プロンプト

現在のコードでは、DBインスタンスやAuthインスタンスがミドルウェアを経由せず、`/auth/*` や `/api/protected` の各ルートハンドラーで**リクエストごとに重複して生成**されています。これは非効率であり、IDマッピングロジックの実装を妨げます。

そこで、まずは **Hono のコンテキスト (DI)** を整備し、その後、残りの2つの必須ステップを実装します。

### 📝 プロンプト本文

「現在、DB (`getDb`) と Auth (`createBetterAuth`) のインスタンスが `/auth/*` や `/api/protected` ルートハンドラー内で**リクエストごとに重複して生成**されています。これは非効率なため、ミドルウェアを利用した **Hono のコンテキスト (DI)** 整備に修正します。

そして、ID分離設計の要である **IDマッピング処理** と、**API保護ミドルウェア** を実装し、フェーズ 1 を完了させます。

以下の **3つのタスク** を順番に実行してください。

### タスク 1: Hono のコンテキスト整備とインスタンス注入（DI）

`src/index.ts` を修正し、DBインスタンスと Authインスタンスをリクエストコンテキストに一度だけ注入するミドルウェアを作成してください。

1.  **Hono Context (Variables) の拡張:** Hono のメインアプリ (`app`) に、`db` (DrizzleD1Database) と `auth` (BetterAuthインスタンス) を格納するための `Variables` 型定義を追加します。
2.  **DI ミドルウェアの作成:** `/` と `/health` 以外の**全てのリクエスト**に対して、`getDb(c.env.DB)` と `createBetterAuth(db, c.env)` を実行し、結果を `c.set('db', db)` と `c.set('auth', auth)` でコンテキストに格納するミドルウェアを作成し、`app.use('*', ...)` として適用してください。
3.  **既存ルートの修正:** `/auth/*` と `/api/protected` ルートハンドラーから、**重複している `getDb` と `createBetterAuth` の呼び出しを削除**し、コンテキスト (`c.get('db')`, `c.get('auth')`) からインスタンスを取得するように修正してください。

### タスク 2: ID マッピング処理の実装（Callbacks フック）

`src/auth.ts` を修正し、ユーザーの**初回ログイン時**に Better Auth ID と業務 ID を紐づけるロジックを実装してください。

1.  **依存関係の追加:** `src/auth.ts` に `drizzle-orm` の `eq`, `db`、および `src/db/schema/user.ts` から `users` と `authMappings` をインポートしてください。
2.  **`callbacks` の実装:** `createBetterAuth` 関数内で、Better Auth の `callbacks.user` フックを実装します。
    * **ロジック:** フック内で、渡された `authUserId` を使って `authMappings` テーブルを検索します。
    * **新規ユーザー処理:** マッピングが存在しない場合、**トランザクション**内で以下の処理を実行してください。
        * `users` テーブルに新規レコードを作成し、`appUserId`（`users.id`）を取得する。
        * `authMappings` テーブルに `appUserId` と `authUserId` の紐づけレコードを作成する。
    * **セッションへの注入:** 最終的に、取得または作成した `appUserId` を `session` オブジェクトのカスタムプロパティ（例: `appUserId: number`）として含めて返してください。

### タスク 3: API 保護ミドルウェアの実装とID分離の完了

`src/index.ts` の `/api/protected` ルートを、ID分離設計に基づいて**業務 ID (`users.id`)** を利用するように修正します。

1.  **ルーティングの整理:** `/api` グループを作成し、`/api/protected` ルートをその下に移動してください。
2.  **ミドルウェアの定義:** `/api/*` ルートに対して適用する認証ミドルウェアを定義し、以下の処理を行ってください。
    * `c.get('auth').api.getSession()` を呼び出し、セッションを検証する。
    * セッションがない場合、`401 Unauthorized` を返す。
    * セッションから `authUserId` を取得し、`authMappings` テーブルを参照して対応する**`appUserId`** を取得する。
    * 取得した `appUserId` を Hono コンテキスト（例: `c.set('appUserId', appUserId)`）に格納する。
3.  **`api/protected` の修正:** ルートハンドラー内で `c.get('auth').api.getSession()` を削除し、`c.get('appUserId')` を使って応答を返すように修正してください。」

## 全部終わったらやったほうがいいことも洗い出して整理

「🚀 フェーズ 1: アプリケーションの動作環境の完成」の3つのタスクを実装し終えたと仮定し、**その次にチーム開発を進める上で優先的に取り組むべき作業**を整理します。

この次のフェーズは、前に述べた「📦 フェーズ 2: 開発体験 (DX) の向上とクリーンアップ」と「🌎 フェーズ 3: デプロイ環境の準備」を具体化したものです。

---

## ⏭️ フェーズ 2: 次のステップ（実装完了後）

### 1. 📦 開発体験 (DX) の向上とコードの整理 (優先度：高)

基盤が動作するようになったら、チームメンバーが**安全かつ効率的**に業務ロジックを書けるようにするための環境整備を行います。

#### 1-1. DB アクセスオブジェクト (DAO/Repository) の整備
* **目的:** Drizzle ORM の生クエリをルートハンドラーから分離し、**再利用性**と**テスト容易性**を向上させます。
* **具体策:** `src/db/repositories/` ディレクトリなどを設け、`UserRepository.ts` のようなファイルに `getUserById(db, id)` や `createUser(db, data)` などのCRUD操作を集約します。
* **メリット:** API 実装者は DB の詳細（Drizzleの `select().from()` など）を意識せず、ビジネスロジックに集中できます。

#### 1-2. 環境変数の整理とドキュメント化
* **目的:** チームメンバーがスムーズにローカル開発を開始できるようにします。
* **具体策:**
    * `.env.example` や `.dev.vars.example` に記載されている `YOUR_DB_NAME` や `BETTER_AUTH_SECRET` などの値を、**実際の開発用デフォルト値**で埋めるか、具体的な設定指示を追記します。
    * `README.md` に、**DBのセットアップ手順**（`pnpm generate`, `pnpm local:migration`）と**サーバー起動コマンド**（`pnpm dev`）を明確に記載します。

#### 1-3. エラーハンドリングミドルウェアの統一
* **目的:** API がクラッシュした際に、統一された形式でエラー応答（JSON）を返すようにします。
* **具体策:** Hono の `app.onError` を利用し、認証エラー (401)、バリデーションエラー (400)、サーバーエラー (500) などに対して、**適切な HTTP ステータスコード**と**統一された JSON ボディ**で応答する処理を実装します。

---

### 2. 🌎 デプロイ環境の準備 (優先度：中)

ローカルで動作確認ができたら、いよいよ本番環境への道筋をつけます。

#### 2-1. リモート D1 へのマイグレーション実行
* **目的:** Cloudflare の本番環境の D1 データベースにも、ローカルと同じテーブル構造を作成します。
* **具体策:** `package.json` にある `pnpm remote:migration` コマンド内の DB バインディング名（現在は `xxx` や `YOUR_DB_NAME` のまま）を**本番環境の正しい名前**に修正し、実行します。

#### 2-2. 認証プロバイダの設定
* **目的:** 開発/テスト用に、実際の Google や GitHub などの認証プロバイダをBetter Authに組み込みます。
* **具体策:**
    * `src/auth.ts` の `createBetterAuth` 関数に `providers` 配列を追加します。
    * `GOOGLE_CLIENT_ID` や `GITHUB_CLIENT_SECRET` などのキーを `.dev.vars.example` に追記し、Worker Secrets として設定する準備をします。

---

### 3. 🧪 テストの強化 (優先度：中)

実装したコアロジックの信頼性を高めます。

#### 3-1. 認証/マッピングロジックのテスト
* **目的:** IDマッピング処理（タスク 2）が、新規ユーザー/既存ユーザーの両方で正しく動作し、データ整合性が保たれることを保証します。
* **具体策:** Vitest と `vitest-pool-workers` を使用し、**`auth.ts` のコールバックフック**が以下のケースで期待通りに動作するかを確認するテストケースを作成します。
    * 新規ユーザーとしてサインインした際に、`users` と `auth_mappings` にレコードが作成されること。
    * 2回目以降のサインイン時に、新しい `users` レコードが**作成されない**こと。

補足 (DIの範囲)
タスク 1 で app.use('*', ...) を使うと、/health や / ルートにも不要なインスタンス生成ミドルウェアが適用されてしまいます。リクエストのパスに応じてミドルウェアを適用する方が効率的です。

これは次の実装フェーズでの微調整で対応できますが、DIミドルウェアを /api/* や /auth/* の前に、より限定的なパスで適用することで、パフォーマンスをわずかに向上できます。

