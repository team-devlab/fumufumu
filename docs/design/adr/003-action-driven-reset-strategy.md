# ADR 003: アクション駆動によるフォーム状態のリセット方針

## ステータス

承認済み (Accepted)

## コンテキスト

ADR 001およびADR 002の決定により、相談投稿フォームの入力内容はGlobal State (Zustand) で永続化されることになった。
これにより、ユーザーが意図せずページを離脱してもデータが残るメリットがある反面、新規作成時や投稿完了時に適切にデータを消去（クリーンアップ）しなければ、古いデータが残り続ける問題が発生する。

このクリーンアップ処理を「いつ」「どのように」実行するかについて、実装方針を決定する必要がある。

## 検討された選択肢

### 1. ライフサイクル駆動 (Lifecycle-Driven / Mount-based)

* **手法:** 入力画面コンポーネント (`page.tsx`) の `useEffect` を利用し、マウント時（画面が表示された瞬間）にリセットを実行する。
* **特徴:** 画面にアクセスすれば自動的にリセットされるため、実装漏れが起きにくい。

### 2. アクション駆動 (Action-Driven / Event-based)

* **手法:** ユーザーの明示的な操作（「新規作成ボタン」クリック、「投稿ボタン」クリックなど）をトリガーとしてリセットを実行する。
* **特徴:** 「ボタンを押したから消える」という因果関係が明確。

## 決定事項

**「2. アクション駆動 (Action-Driven)」を採用する。**

## 決定の根拠

### 1. 副作用（Side Effects）の回避と堅牢性

* **vs ライフサイクル駆動:** React (特にNext.jsのStrict Mode) において、`useEffect` は開発時に2回実行されるなど挙動が複雑であり、意図しないタイミングでのリセットや、Hydrationエラー（サーバーとクライアントの不整合）の温床となりやすい。
* **アクション駆動の利点:** イベントハンドラ内で実行されるため、ReactのレンダリングサイクルやHydrationの影響を受けず、確実に意図したタイミングでのみ実行される。

### 2. UX: 誤操作からの復帰（Restore）機能

* ライフサイクル駆動の場合、ユーザーが誤ってタブを閉じてしまい、慌ててURL履歴から戻ってきたとしても、マウント時に無条件でリセットが走りデータが消失する。
* アクション駆動の場合、URL直打ちや履歴からのアクセスではリセットが走らないため、**「前回の書きかけデータが残っている」状態となり、結果としてドラフト復元機能として機能する。**

### 3. ロジックの明快さ

* 「どの画面を開いたか」に依存する暗黙的なリセットよりも、「どのボタンを押したか」に依存する明示的なリセットの方が、コードを読んだ際の因果関係が理解しやすい。

## 実装詳細 (Implementation Details)

データの不整合を防ぐため、以下のタイミング（Entry/Exit）でStoreの `reset` アクションを実行する。

### 1. Entry Point (フロー開始時)

* **ヘッダー「新規作成」ボタン:**
* `Link` コンポーネントではなく、`onClick` ハンドラを持つボタンとして実装する。
* ハンドラ内で `store.reset()` を実行してから、`/consultations/new` へ遷移 (`router.push`) する。



### 2. Exit Point (フロー終了時)

* **投稿成功時:** APIレスポンスが成功（200 OK）した直後に `store.reset()` を実行し、一覧画面へ遷移する。
* **明示的なキャンセル時:** 「一覧へ戻る」ボタン押下時など、文脈に応じてリセットを実行する（要件により維持を選択する場合を除く）。

### 3. URL直打ち時の扱い

* ユーザーがURL (`/consultations/new`) を直接入力してアクセスした場合は、リセット処理を行わず、Storeに残っているデータをそのまま表示する（復元挙動としての仕様とする）。

## 結果 (Consequences)

* `useEffect` を使用しないため、コードが簡潔になり、レンダリングに関するバグが減少する。
* リセットのトリガーとなる箇所（ヘッダー、完了画面など）すべてに `reset()` の呼び出しを実装する必要がある（実装漏れに注意が必要）。
* ユーザーにとって「書きかけのデータが消えにくい」安心感のあるUXが実現される。
