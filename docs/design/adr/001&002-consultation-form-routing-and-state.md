
# ADR 001: 相談投稿機能における画面遷移とデータ保持方式の決定

## ステータス

承認済み (Accepted)

## コンテキスト

相談投稿機能の実装において、ユーザーは「入力画面」でタイトルや相談内容（最大800文字）を入力し、その後「確認画面」を経て投稿を行う。
この際、入力画面から確認画面への遷移方法、およびその間のデータ保持方法について、ユーザー体験（UX）と開発体験（DX/保守性）のバランスを考慮した設計が必要となった。

## 検討された選択肢

### 1. 画面遷移の方式

* **A案: コンポーネント出し分け (Single Route)**
* URLを変更せず (`/consultations/new`)、React Stateのフラグによって表示コンポーネントを切り替える。


* **B案: 別ルートへの遷移 (Separate Route)**
* URLを明確に分ける (`/consultations/new` → `/consultations/new/confirm`)。



### 2. データ保持の方式 (B案採用時のデータ受け渡し)

* **URL Query Parameters**: URL末尾にデータを含める (`?title=...&body=...`)。
* **Web Storage (Local/Session)**: ブラウザのストレージに一時保存する。
* **Global State (In-Memory)**: JavaScriptメモリ上のストアで保持する。

## 決定事項

**「B案: 別ルートへの遷移」を採用し、データ保持には「Global State (In-Memory)」を使用する。**

## 決定の根拠

### 1. UX上の安全性 (Decision Driver)

本機能は最大800文字の長文入力を伴う。
A案（コンポーネント出し分け）の場合、確認画面でユーザーがブラウザの「戻る」ボタンを押すと、アプリケーションのトップページや前閲覧サイトに戻ってしまい、**入力内容が全消失するリスク**が極めて高い。
B案（別ルート遷移）であれば、ブラウザの「戻る」操作で自然に入力画面へ復帰でき、データを維持したまま修正が可能であるため、ユーザー体験の安全性を最優先とした。

### 2. 技術的制約による除外

* **URL Query Parametersの却下**:
* 日本語を含む長文（800文字以上）をURLエンコードすると、ブラウザのURL長制限（一般的に約2000byte前後で安全性が低下）に抵触し、エラーとなる可能性が高いため。


* **Web Storageの却下**:
* Next.js (Server Component) におけるHydration Errorのリスクや、投稿完了時・離脱時の「ゴミデータ削除（Cleanup）」の実装コストが過大であり、スモールステップの実装に適さないため。



### 3. 計測と拡張性

URLが分離されることで、Google Analytics等での「確認画面到達率」や「離脱率」の計測が容易になる。また、将来的に入力ステップが増える場合（ウィザード形式など）にも対応しやすいアーキテクチャである。

## 結果 (Consequences)

### メリット

* ユーザーがブラウザ標準のナビゲーション（戻る/進む）を使用してもデータが失われない。
* ページごとの責務が分離され、コードの見通しが良くなる。
* URLベースでのアクセス解析が可能になる。

### デメリット / リスク

* A案と比較して、データをページ間で受け渡すための「状態管理」の仕組みを導入する必要がある（→ **ADR 002** で解決）。
* 実装工数はA案よりも若干増加する。

---

# ADR 002: フォーム状態管理ライブラリとしてのZustandの採用

## ステータス

承認済み (Accepted)

## コンテキスト

ADR 001の決定により、入力画面と確認画面の間でフォームデータを共有する必要が生じた。
Next.js App Router環境下において、スモールステップで導入でき、かつ保守性が高い状態管理手法を選定する必要がある。

## 検討された選択肢

1. **React Context API (標準機能)**
2. **Redux Toolkit (RTK)**
3. **Jotai**
4. **Valtio**
5. **XState**
6. **Zustand**

## 決定事項

**状態管理ライブラリとして「Zustand」を採用する。**

## 決定の根拠

### 1. 既存アーキテクチャへの影響の最小化

* **vs Context API**: Context APIの場合、`layout.tsx` 等にProviderコンポーネントを配置しラップする必要があり、コンポーネントツリーの構造変更を余儀なくされる。ZustandはStoreがReactツリー外で独立しているため、既存のファイル構造を変更せずに導入・利用が可能である。

### 2. ボイラープレートの少なさと学習コスト

* **vs Redux Toolkit**: Reduxは堅牢だが、Store設定・Slice定義・Provider配置など準備コード（ボイラープレート）が多すぎ、単一機能のフォーム実装にはオーバースペックである。
* **vs XState**: 状態遷移が単純な一本道（入力→確認→完了）であるため、ステートマシン導入は過剰なエンジニアリングとなる。

### 3. データ構造との親和性

* **vs Jotai**: フォームデータ（Title, Body, Tags等）は「ひとまとまりのオブジェクト」として扱うのが自然である。Jotai（Atomicモデル）はデータを細分化して管理するのに適しており、今回のように一括でリセット処理などを行いたい場合、Zustand（Fluxモデル）の方が直感的に記述できる。

### 4. Reactの原則への準拠

* **vs Valtio**: ValtioはMutable（変数を直接書き換えるスタイル）であり、フォーム実装には強力だが、Immutabilityを前提とするReactの標準的なメンタルモデルと異なる。チーム開発における混乱を避けるため、より標準的なFluxパターンのZustandを選択した。

## 結果 (Consequences)

### メリット

* **実装スピード**: `create` 関数1つでStoreを定義でき、即座にコンポーネントから利用できる。
* **ロジックのカプセル化**: 「データ」だけでなく「リセット処理」や「更新ロジック」をStore内に閉じ込めることができ、コンポーネント側がクリーンに保たれる。
* **パフォーマンス**: 不要な再レンダリングを防ぐSelectorパターンが利用可能。

### デメリット / リスク

* 外部ライブラリ (`zustand`) への依存が1つ増える（ただしバンドルサイズは極小）。
* Storeがグローバルに存在するため、適切なタイミング（投稿完了時や画面初期化時）で明示的にデータをリセットしないと、前回の入力内容が残る可能性がある（実装時に `useEffect` 等で対策する）。

## 実装詳細方針 (Implementation Details)

### 1. データのライフサイクル管理 (Action-Driven Reset)
`useEffect` による初期化（マウント時のリセット）は、HydrationエラーやStrict Modeでの二重実行などの副作用を招くリスクがあるため採用しない。
代わりに、ユーザーのアクションをトリガーとして明示的にStateをリセットする「アクション駆動」の方針を採用する。

* **Entry (開始時):** ヘッダーの「新規作成」ボタンクリック時など、**フローへの進入時**に `store.reset()` を実行してから遷移する。これにより、前回の入力残骸を確実に消去する。
    * *Note:* URL直打ちでのアクセス時はリセットされないが、これは「前回の続きからの復帰（Restore）」として許容する。
* **Exit (終了時):**
    * **Submit Success:** APIへの送信成功直後に `store.reset()` を実行する。
    * **Cancel/Back:** 「一覧に戻る」などの離脱アクション時にも `store.reset()` を実行する（要件に応じて維持も可）。

### 2. ディレクトリ構成
Featuresパターンの原則に従い、Storeは以下に配置する。
* `features/consultation/stores/useConsultationFormStore.ts`

### 3. 編集機能への対応
本アーキテクチャは将来的な「編集機能」への転用を想定している。Storeに初期値注入用のアクション (`setInitialData`) を実装することで、新規作成と編集で同じ確認画面フローを共有可能とする。

### 4. スコープ外事項
* **タグ機能:** 本ADRの適用範囲内において、タグ機能はUI実装のみとし、Storeでの状態管理対象外とする。
